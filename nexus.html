<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Chess Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&family=Playfair+Display:wght@700&display=swap');
        
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 50%, rgba(67, 233, 123, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(99, 102, 241, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.4), 0 0 1px rgba(255,255,255,0.5) inset;
            padding: 40px;
            max-width: 650px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: slideIn 0.6s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        h1 {
            text-align: center;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            letter-spacing: -1px;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
                margin-bottom: 20px;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }
        }
        
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }
        
        @media (max-width: 768px) {
            .controls {
                gap: 8px;
                margin-bottom: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .controls {
                gap: 6px;
                margin-bottom: 15px;
                flex-direction: column;
                width: 100%;
            }
        }
        
        button {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }
        
        @media (max-width: 480px) {
            button {
                padding: 10px 16px;
                font-size: 12px;
                border-radius: 8px;
                width: 100%;
            }
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.3s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 25px rgba(52, 152, 219, 0.4);
        }
        
        button:active {
            transform: translateY(-1px);
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        select {
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid #3498db;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            background: white;
            color: #2c3e50;
            transition: all 0.3s;
            font-family: 'Poppins', sans-serif;
            min-height: 44px;
            -webkit-appearance: none;
        }
        
        @media (max-width: 480px) {
            select {
                padding: 10px 12px;
                font-size: 12px;
                width: 100%;
            }
        }
        
        select:hover {
            border-color: #2980b9;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
        }
        
        #board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            gap: 0;
            margin: 0 auto 30px;
            border: 6px solid #2c3e50;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
            border-radius: 4px;
            animation: boardAppear 0.8s ease-out;
            width: fit-content;
        }
        
        @media (max-width: 768px) {
            #board {
                grid-template-columns: repeat(8, 50px);
                grid-template-rows: repeat(8, 50px);
                margin: 0 auto 20px;
                border-width: 4px;
            }
        }
        
        @media (max-width: 480px) {
            #board {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
                margin: 0 auto 15px;
                border-width: 3px;
            }
        }
        
        @keyframes boardAppear {
            from {
                opacity: 0;
                transform: scale(0.98);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 44px;
            cursor: pointer;
            transition: all 0.15s ease-out;
            user-select: none;
            position: relative;
            touch-action: manipulation;
        }
        
        @media (max-width: 768px) {
            .square {
                width: 50px;
                height: 50px;
                font-size: 32px;
            }
        }
        
        @media (max-width: 480px) {
            .square {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }
        }
        
        .piece {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 1px 2px rgba(255,255,255,0.3);
            transition: all 0.2s;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            .piece {
                width: 45px;
                height: 45px;
                border-radius: 6px;
            }
        }
        
        @media (max-width: 480px) {
            .piece {
                width: 35px;
                height: 35px;
                border-radius: 4px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 1px 2px rgba(255,255,255,0.3);
            }
        }
        
        .white-piece {
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            color: #2c3e50;
        }
        
        .black-piece {
            background: linear-gradient(135deg, #2c3e50 0%, #1a1f2e 100%);
            color: #ffffff;
        }
        
        .square:hover .piece {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.3);
        }
        
        .light {
            background: linear-gradient(135deg, #f5e6d3 0%, #e8d5c4 100%);
        }
        
        .dark {
            background: linear-gradient(135deg, #b89968 0%, #a0824d 100%);
        }
        
        .selected {
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%) !important;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }
        
        .valid-move {
            position: relative;
        }
        
        .valid-move::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, rgba(76, 175, 80, 0.8) 0%, rgba(76, 175, 80, 0.4) 100%);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
        }
        
        .square:hover {
            filter: brightness(1.1);
            transform: scale(1.02);
        }
        
        .status {
            text-align: center;
            margin-top: 25px;
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            min-height: 30px;
            animation: statusFade 0.4s ease;
        }
        
        @media (max-width: 768px) {
            .status {
                font-size: 16px;
                margin-top: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .status {
                font-size: 14px;
                margin-top: 12px;
            }
        }
        
        @keyframes statusFade {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .thinking {
            background: linear-gradient(135deg, #e74c3c 0%, #e67e22 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: glow 1.5s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .info {
            text-align: center;
            margin-top: 12px;
            color: #7f8c8d;
            font-size: 13px;
            font-weight: 500;
        }
        
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
            padding: 20px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .promotion-dialog {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 70px rgba(0,0,0,0.4);
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
            animation: slideUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            width: 100%;
            max-width: 400px;
        }
        
        @media (max-width: 480px) {
            .promotion-dialog {
                padding: 20px;
                border-radius: 12px;
            }
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .promotion-dialog h2 {
            margin-bottom: 25px;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 24px;
            font-family: 'Playfair Display', serif;
        }
        
        .promotion-choices {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        @media (max-width: 480px) {
            .promotion-choices {
                gap: 10px;
            }
        }
        
        .promotion-piece {
            font-size: 70px;
            cursor: pointer;
            padding: 15px;
            border-radius: 12px;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: linear-gradient(135deg, #ecf0f1 0%, #d5dbdb 100%);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 2px solid transparent;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        @media (max-width: 480px) {
            .promotion-piece {
                font-size: 50px;
                padding: 10px;
                border-radius: 8px;
            }
        }
        
        .promotion-piece:hover {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            transform: scale(1.15) rotateZ(-5deg);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
            border-color: rgba(255,255,255,0.3);
        }
        
        .promotion-piece:active {
            transform: scale(0.95);
        }
        
        .player-section {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 480px) {
            .player-section {
                gap: 15px;
                margin-top: 15px;
            }
        }
        
        .player-figure {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: playerBounce 2s ease-in-out infinite;
        }
        
        @keyframes playerBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        .player-head {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #f4a460 0%, #d4886b 100%);
            border-radius: 50%;
            margin-bottom: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative;
        }
        
        .player-head::before {
            content: '‚óè‚óè';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #2c3e50;
            letter-spacing: 2px;
        }
        
        .player-head::after {
            content: '‚Ä¢';
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #c0392b;
        }
        
        .player-body {
            width: 28px;
            height: 35px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 4px;
            margin-bottom: 3px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .player-legs {
            display: flex;
            gap: 3px;
        }
        
        .player-leg {
            width: 6px;
            height: 20px;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .player-label {
            margin-top: 8px;
            font-size: 12px;
            font-weight: 700;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .music-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 100;
            display: flex;
            gap: 10px;
            align-items: center;
            border: 1px solid rgba(52, 152, 219, 0.3);
            backdrop-filter: blur(10px);
        }
        
        @media (max-width: 768px) {
            .music-panel {
                top: 10px;
                right: 10px;
                padding: 10px;
                gap: 8px;
            }
        }
        
        @media (max-width: 480px) {
            .music-panel {
                top: 8px;
                right: 8px;
                padding: 8px;
                gap: 6px;
            }
        }
        
        .music-control {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            -webkit-tap-highlight-color: transparent;
            min-width: 44px;
            min-height: 44px;
        }
        
        @media (max-width: 480px) {
            .music-control {
                width: 44px;
                height: 44px;
                font-size: 20px;
            }
        }
        
        .music-control:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }
        
        .music-control.muted {
            background: #95a5a6;
        }
        
        .music-selector {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #3498db;
            font-size: 12px;
            background: white;
            color: #2c3e50;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            transition: all 0.3s;
            -webkit-appearance: none;
        }
        
        @media (max-width: 480px) {
            .music-selector {
                font-size: 10px;
                padding: 4px 6px;
                display: none;
            }
        }
        
        .music-selector:hover {
            border-color: #2980b9;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
        }
        
        .ai-speech {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px 35px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 320px;
            text-align: center;
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            z-index: 1500;
            animation: speechBounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid #3498db;
            margin: 0 20px;
            width: calc(100% - 40px);
        }
        
        @media (max-width: 480px) {
            .ai-speech {
                padding: 15px 20px;
                max-width: 90vw;
                font-size: 14px;
                border-radius: 12px;
                margin: 0 5vw;
                width: 90vw;
            }
        }
        
        @keyframes speechBounce {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .ai-speech::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid white;
        }
        
        .checkmate-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.5s ease;
        }
        
        .checkmate-message {
            background: white;
            padding: 60px 80px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 100px rgba(0,0,0,0.5);
            animation: scaleIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.3) rotateZ(-10deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotateZ(0deg);
            }
        }
        
        .checkmate-message h2 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #e74c3c 0%, #f39c12 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Playfair Display', serif;
            animation: bounce 0.6s ease;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        .checkmate-message p {
            font-size: 24px;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .engine-name {
            font-size: 28px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .stalemate-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.5s ease;
        }
        
        .stalemate-message {
            background: white;
            padding: 60px 80px;
            border-radius: 24px;
            text-align: center;
            box-shadow: 0 20px 100px rgba(0,0,0,0.5);
            animation: scaleIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .stalemate-message h2 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Playfair Display', serif;
            animation: bounce 0.6s ease;
        }
        
        .stalemate-message p {
            font-size: 24px;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        .color-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 12px;
        }
        
        @media (max-width: 480px) {
            .color-selector {
                gap: 8px;
                padding: 8px;
                margin-bottom: 12px;
            }
        }
        
        .color-btn {
            padding: 8px 16px;
            border: 2px solid #3498db;
            background: white;
            color: #2c3e50;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
            -webkit-tap-highlight-color: transparent;
            min-height: 40px;
            flex: 1;
        }
        
        @media (max-width: 480px) {
            .color-btn {
                padding: 8px 12px;
                font-size: 12px;
                min-height: 44px;
            }
        }
        
        .color-btn:hover {
            background: #3498db;
            color: white;
            transform: scale(1.05);
        }
        
        .color-btn.active {
            background: #3498db;
            color: white;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }
    </style>
</head>
<body>
    <div class="music-panel">
        <select class="music-selector" id="musicSelector" onchange="changeMusic()">
            <option value="epic">Epic Battle</option>
            <option value="classical">Classical Piano</option>
            <option value="ambient">Ambient Zen</option>
            <option value="jazz">Jazz Lounge</option>
            <option value="electronic">Electronic Focus</option>
        </select>
        <button class="music-control" id="musicControl" onclick="toggleMusic()">üîä</button>
    </div>
    
    <audio id="backgroundMusic" loop>
        <source id="musicSource" type="audio/mpeg">
    </audio>
    
    <div class="checkmate-overlay" id="checkmateOverlay">
        <div class="checkmate-message">
            <div class="engine-name">‚ö° NEXUS ‚ö°</div>
            <h2>‚ôî CHECKMATE ‚ôö</h2>
            <p id="checkmateText"></p>
            <button onclick="newGame()" style="margin-top: 20px; padding: 15px 40px; font-size: 16px;">Play Again</button>
        </div>
    </div>
    
    <div class="stalemate-overlay" id="stalemateOverlay">
        <div class="stalemate-message">
            <div class="engine-name">‚ö° NEXUS ‚ö°</div>
            <h2>‚öñÔ∏è STALEMATE ‚öñÔ∏è</h2>
            <p>It's a Draw!</p>
            <button onclick="newGame()" style="margin-top: 20px; padding: 15px 40px; font-size: 16px;">Play Again</button>
        </div>
    </div>
    
    <div class="ai-speech" id="aiSpeech" style="display: none;"></div>
    
    <div class="container">
        <h1>‚ôî Chess Engine ‚ôö</h1>
        
        <div class="color-selector">
            <button class="color-btn active" id="whiteBtn" onclick="selectColor('white')">Play as White ‚ôî</button>
            <button class="color-btn" id="blackBtn" onclick="selectColor('black')">Play as Black ‚ôö</button>
        </div>
        
        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="undoMove()" id="undoBtn">Undo Move</button>
            <select id="difficulty" onchange="changeDifficulty()">
                <option value="2">Easy (Depth 2)</option>
                <option value="3" selected>Medium (Depth 3)</option>
                <option value="4">Hard (Depth 4)</option>
                <option value="5">Expert (Depth 5)</option>
            </select>
        </div>
        
        <div id="board"></div>
        
        <div class="player-section">
            <div class="player-figure">
                <div class="player-head"></div>
                <div class="player-body"></div>
                <div class="player-legs">
                    <div class="player-leg"></div>
                    <div class="player-leg"></div>
                </div>
                <div class="player-label">You (White)</div>
            </div>
        </div>
        
        <div class="status" id="status">Your turn (White)</div>
        <div class="info" id="info"></div>
    </div>
    
    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-dialog">
            <h2>Choose Promotion</h2>
            <div class="promotion-choices" id="promotionChoices"></div>
        </div>
    </div>

    <script>
        const PIECES = {
            P: '‚ôô', N: '‚ôò', B: '‚ôó', R: '‚ôñ', Q: '‚ôï', K: '‚ôî',
            p: '‚ôü', n: '‚ôû', b: '‚ôù', r: '‚ôú', q: '‚ôõ', k: '‚ôö'
        };
        
        const PIECE_VALUES = {
            p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000,
            P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000
        };
        
        const PAWN_TABLE = [
            0,  0,  0,  0,  0,  0,  0,  0,
            50, 50, 50, 50, 50, 50, 50, 50,
            10, 10, 20, 30, 30, 20, 10, 10,
            5,  5, 10, 25, 25, 10,  5,  5,
            0,  0,  0, 20, 20,  0,  0,  0,
            5, -5,-10,  0,  0,-10, -5,  5,
            5, 10, 10,-20,-20, 10, 10,  5,
            0,  0,  0,  0,  0,  0,  0,  0
        ];
        
        const KNIGHT_TABLE = [
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50
        ];
        
        const BISHOP_TABLE = [
            -20,-10,-10,-10,-10,-10,-10,-20,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -10,  0,  5, 10, 10,  5,  0,-10,
            -10,  5,  5, 10, 10,  5,  5,-10,
            -10,  0, 10, 10, 10, 10,  0,-10,
            -10, 10, 10, 10, 10, 10, 10,-10,
            -10,  5,  0,  0,  0,  0,  5,-10,
            -20,-10,-10,-10,-10,-10,-10,-20
        ];
        
        const KING_TABLE = [
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -20,-30,-30,-40,-40,-30,-30,-20,
            -10,-20,-20,-20,-20,-20,-20,-10,
            20, 20,  0,  0,  0,  0, 20, 20,
            20, 30, 10,  0,  0, 10, 30, 20
        ];
        
        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let moveHistory = [];
        let searchDepth = 3;
        let playerColor = 'white';
        let castlingRights = {
            whiteKing: true,
            whiteQueenside: true,
            blackKing: true,
            blackQueenside: true
        };
        let pendingPromotion = null;
        let musicPlaying = true;
        let lastMove = null;
        
        const AI_MESSAGES = [
            "Hmm, interesting move...",
            "Let me think about this...",
            "I see what you're doing!",
            "Bold strategy, let's see...",
            "Calculating my next move...",
            "Your move is clever!",
            "Processing... ü§î",
            "Analyzing the board...",
            "That won't stop me!",
            "I've got a plan...",
            "Interesting choice!",
            "Let me counter that...",
            "Thinking ahead...",
            "I see the tactics!",
            "Time to strike!"
        ];
        
        function initBoard() {
            board = [
                ['r','n','b','q','k','b','n','r'],
                ['p','p','p','p','p','p','p','p'],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['P','P','P','P','P','P','P','P'],
                ['R','N','B','Q','K','B','N','R']
            ];
            selectedSquare = null;
            currentPlayer = 'white';
            moveHistory = [];
            castlingRights = {
                whiteKing: true,
                whiteQueenside: true,
                blackKing: true,
                blackQueenside: true
            };
            renderBoard();
            updateStatus();
            
            // If player chose black, AI starts with white
            if (playerColor === 'black') {
                currentPlayer = 'white';
                updateStatus('AI is thinking...');
                setTimeout(makeAIMove, 500);
            }
        }
        
        function selectColor(color) {
            playerColor = color;
            document.getElementById('whiteBtn').classList.toggle('active', color === 'white');
            document.getElementById('blackBtn').classList.toggle('active', color === 'black');
            newGame();
        }
        
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            const isWhitePiece = (piece) => piece === piece.toUpperCase();
            
            // Reverse iteration if playing as black
            const rows = playerColor === 'black' ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
            const cols = playerColor === 'black' ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
            
            for (let rowIdx of rows) {
                for (let colIdx of cols) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((rowIdx + colIdx) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = rowIdx;
                    square.dataset.col = colIdx;
                    
                    if (selectedSquare && selectedSquare.row === rowIdx && selectedSquare.col === colIdx) {
                        square.classList.add('selected');
                    }
                    
                    const piece = board[rowIdx][colIdx];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = `piece ${isWhitePiece(piece) ? 'white-piece' : 'black-piece'}`;
                        pieceEl.textContent = PIECES[piece];
                        square.appendChild(pieceEl);
                    }
                    
                    square.onclick = () => handleSquareClick(rowIdx, colIdx);
                    boardEl.appendChild(square);
                }
            }
        }
        
        function handleSquareClick(row, col) {
            if (currentPlayer !== playerColor || pendingPromotion) return;
            
            const piece = board[row][col];
            
            if (selectedSquare) {
                const moves = getValidMoves(selectedSquare.row, selectedSquare.col);
                const move = moves.find(m => m.row === row && m.col === col);
                
                if (move) {
                    executeMove(selectedSquare.row, selectedSquare.col, row, col, move);
                } else if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                    selectedSquare = {row, col};
                    renderBoard();
                    highlightMoves(row, col);
                } else {
                    selectedSquare = null;
                    renderBoard();
                }
            } else if (piece && ((playerColor === 'white' && isWhitePiece(piece)) || (playerColor === 'black' && isBlackPiece(piece)))) {
                selectedSquare = {row, col};
                renderBoard();
                highlightMoves(row, col);
            }
        }
        
        function executeMove(fromRow, fromCol, toRow, toCol, moveData) {
            const piece = board[fromRow][fromCol];
            
            // Check for promotion
            if (piece && piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                pendingPromotion = {fromRow, fromCol, toRow, toCol, moveData};
                showPromotionDialog(isWhitePiece(piece));
                return;
            }
            
            finishMove(fromRow, fromCol, toRow, toCol, moveData);
        }
        
        function finishMove(fromRow, fromCol, toRow, toCol, moveData, promotion = null) {
            saveState();
            
            const piece = board[fromRow][fromCol];
            
            // Handle castling
            if (moveData && moveData.castle) {
                if (moveData.castle === 'K') {
                    board[7][6] = 'K';
                    board[7][4] = null;
                    board[7][5] = 'R';
                    board[7][7] = null;
                } else if (moveData.castle === 'Q') {
                    board[7][2] = 'K';
                    board[7][4] = null;
                    board[7][3] = 'R';
                    board[7][0] = null;
                } else if (moveData.castle === 'k') {
                    board[0][6] = 'k';
                    board[0][4] = null;
                    board[0][5] = 'r';
                    board[0][7] = null;
                } else if (moveData.castle === 'q') {
                    board[0][2] = 'k';
                    board[0][4] = null;
                    board[0][3] = 'r';
                    board[0][0] = null;
                }
            } else {
                // Normal move or en passant
                if (moveData && moveData.enPassant) {
                    // En passant: capture the pawn beside, not in front
                    board[fromRow][toCol] = null;
                }
                board[toRow][toCol] = promotion || piece;
                board[fromRow][fromCol] = null;
            }
            
            // Track last move
            lastMove = {from: {r: fromRow, c: fromCol}, to: {r: toRow, c: toCol}};
            
            // Update castling rights
            if (piece === 'K') {
                castlingRights.whiteKing = false;
                castlingRights.whiteQueenside = false;
            } else if (piece === 'k') {
                castlingRights.blackKing = false;
                castlingRights.blackQueenside = false;
            } else if (piece === 'R') {
                if (fromRow === 7 && fromCol === 7) castlingRights.whiteKing = false;
                if (fromRow === 7 && fromCol === 0) castlingRights.whiteQueenside = false;
            } else if (piece === 'r') {
                if (fromRow === 0 && fromCol === 7) castlingRights.blackKing = false;
                if (fromRow === 0 && fromCol === 0) castlingRights.blackQueenside = false;
            }
            
            selectedSquare = null;
            renderBoard();
            
            if (playerColor === 'white') {
                if (isCheckmate('black')) {
                    setTimeout(() => {
                        document.getElementById('checkmateOverlay').style.display = 'flex';
                        document.getElementById('checkmateText').textContent = 'You win! üéâ';
                    }, 500);
                } else if (isStalemate('black')) {
                    setTimeout(() => {
                        document.getElementById('stalemateOverlay').style.display = 'flex';
                    }, 500);
                } else if (!isCheckmate('black') && !isStalemate('black')) {
                    currentPlayer = 'black';
                    updateStatus('AI is thinking...');
                    setTimeout(makeAIMove, 100);
                } else {
                    updateStatus();
                }
            } else {
                if (isCheckmate('white')) {
                    setTimeout(() => {
                        document.getElementById('checkmateOverlay').style.display = 'flex';
                        document.getElementById('checkmateText').textContent = 'You win! üéâ';
                    }, 500);
                } else if (isStalemate('white')) {
                    setTimeout(() => {
                        document.getElementById('stalemateOverlay').style.display = 'flex';
                    }, 500);
                } else if (!isCheckmate('white') && !isStalemate('white')) {
                    currentPlayer = 'white';
                    updateStatus('AI is thinking...');
                    setTimeout(makeAIMove, 100);
                } else {
                    updateStatus();
                }
            }
        }
        
        function showPromotionDialog(isWhite) {
            const modal = document.getElementById('promotionModal');
            const choices = document.getElementById('promotionChoices');
            choices.innerHTML = '';
            
            const pieces = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            
            pieces.forEach(p => {
                const piece = document.createElement('div');
                piece.className = 'promotion-piece';
                piece.textContent = PIECES[p];
                piece.onclick = () => handlePromotion(p);
                choices.appendChild(piece);
            });
            
            modal.style.display = 'flex';
        }
        
        function handlePromotion(piece) {
            const modal = document.getElementById('promotionModal');
            modal.style.display = 'none';
            
            if (pendingPromotion) {
                const {fromRow, fromCol, toRow, toCol, moveData} = pendingPromotion;
                pendingPromotion = null;
                finishMove(fromRow, fromCol, toRow, toCol, moveData, piece);
            }
        }
        
        function highlightMoves(row, col) {
            const moves = getValidMoves(row, col);
            moves.forEach(move => {
                const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                if (square) square.classList.add('valid-move');
            });
        }
        
        function isWhitePiece(piece) {
            return piece === piece.toUpperCase();
        }
        
        function isBlackPiece(piece) {
            return piece === piece.toLowerCase();
        }
        
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const isWhite = isWhitePiece(piece);
            const moves = [];
            const type = piece.toLowerCase();
            
            const addMoveIfValid = (r, c, extra = {}) => {
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const target = board[r][c];
                    if (!target || (isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
                        const originalPiece = board[r][c];
                        board[r][c] = piece;
                        board[row][col] = null;
                        
                        if (!isInCheck(isWhite ? 'white' : 'black')) {
                            moves.push({row: r, col: c, ...extra});
                        }
                        
                        board[row][col] = piece;
                        board[r][c] = originalPiece;
                        return !target;
                    }
                }
                return false;
            };
            
            if (type === 'p') {
                const dir = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                
                if (!board[row + dir]?.[col]) {
                    addMoveIfValid(row + dir, col);
                    if (row === startRow && !board[row + 2*dir]?.[col]) {
                        addMoveIfValid(row + 2*dir, col);
                    }
                }
                
                [-1, 1].forEach(dc => {
                    const target = board[row + dir]?.[col + dc];
                    if (target && ((isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target)))) {
                        addMoveIfValid(row + dir, col + dc);
                    }
                });
                
                // En passant
                if (lastMove) {
                    const lastPiece = board[lastMove.from.r]?.[lastMove.from.c];
                    if (!lastPiece && board[row]?.[lastMove.to.c]?.toLowerCase() === 'p') {
                        const lastMovedPiece = board[lastMove.to.r]?.[lastMove.to.c]?.toLowerCase();
                        if (lastMovedPiece === 'p' && Math.abs(lastMove.to.r - lastMove.from.r) === 2 && lastMove.to.c === col + 1) {
                            if ((isWhite && lastMove.from.r > lastMove.to.r) || (!isWhite && lastMove.from.r < lastMove.to.r)) {
                                addMoveIfValid(lastMove.to.r + dir, lastMove.to.c, {enPassant: true});
                            }
                        }
                    }
                    if (!lastPiece && board[row]?.[lastMove.to.c]?.toLowerCase() === 'p') {
                        const lastMovedPiece = board[lastMove.to.r]?.[lastMove.to.c]?.toLowerCase();
                        if (lastMovedPiece === 'p' && Math.abs(lastMove.to.r - lastMove.from.r) === 2 && lastMove.to.c === col - 1) {
                            if ((isWhite && lastMove.from.r > lastMove.to.r) || (!isWhite && lastMove.from.r < lastMove.to.r)) {
                                addMoveIfValid(lastMove.to.r + dir, lastMove.to.c, {enPassant: true});
                            }
                        }
                    }
                }
            } else if (type === 'n') {
                [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc]) => {
                    addMoveIfValid(row + dr, col + dc);
                });
            } else if (type === 'b' || type === 'q') {
                [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc]) => {
                    for (let i = 1; i < 8; i++) {
                        if (!addMoveIfValid(row + i*dr, col + i*dc)) break;
                    }
                });
            }
            
            if (type === 'r' || type === 'q') {
                [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc]) => {
                    for (let i = 1; i < 8; i++) {
                        if (!addMoveIfValid(row + i*dr, col + i*dc)) break;
                    }
                });
            } else if (type === 'k') {
                [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc]) => {
                    addMoveIfValid(row + dr, col + dc);
                });
                
                // Castling
                if (isWhite && row === 7 && col === 4) {
                    if (castlingRights.whiteKing && !board[7][5] && !board[7][6] && 
                        board[7][7] === 'R' && !isSquareAttacked(7, 4, 'black') && 
                        !isSquareAttacked(7, 5, 'black') && !isSquareAttacked(7, 6, 'black')) {
                        moves.push({row: 7, col: 6, castle: 'K'});
                    }
                    if (castlingRights.whiteQueenside && !board[7][3] && !board[7][2] && !board[7][1] &&
                        board[7][0] === 'R' && !isSquareAttacked(7, 4, 'black') && 
                        !isSquareAttacked(7, 3, 'black') && !isSquareAttacked(7, 2, 'black')) {
                        moves.push({row: 7, col: 2, castle: 'Q'});
                    }
                } else if (!isWhite && row === 0 && col === 4) {
                    if (castlingRights.blackKing && !board[0][5] && !board[0][6] && 
                        board[0][7] === 'r' && !isSquareAttacked(0, 4, 'white') && 
                        !isSquareAttacked(0, 5, 'white') && !isSquareAttacked(0, 6, 'white')) {
                        moves.push({row: 0, col: 6, castle: 'k'});
                    }
                    if (castlingRights.blackQueenside && !board[0][3] && !board[0][2] && !board[0][1] &&
                        board[0][0] === 'r' && !isSquareAttacked(0, 4, 'white') && 
                        !isSquareAttacked(0, 3, 'white') && !isSquareAttacked(0, 2, 'white')) {
                        moves.push({row: 0, col: 2, castle: 'q'});
                    }
                }
            }
            
            return moves;
        }
        
        function isSquareAttacked(row, col, byPlayer) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && ((byPlayer === 'white' && isWhitePiece(piece)) || 
                                  (byPlayer === 'black' && isBlackPiece(piece)))) {
                        const moves = getValidMovesWithoutCheckTest(r, c);
                        if (moves.some(m => m.row === row && m.col === col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function isInCheck(player) {
            let kingPos = null;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.toLowerCase() === 'k') {
                        if ((player === 'white' && isWhitePiece(piece)) || 
                            (player === 'black' && isBlackPiece(piece))) {
                            kingPos = {r, c};
                        }
                    }
                }
            }
            
            if (!kingPos) return false;
            
            return isSquareAttacked(kingPos.r, kingPos.c, player === 'white' ? 'black' : 'white');
        }
        
        function getValidMovesWithoutCheckTest(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const isWhite = isWhitePiece(piece);
            const moves = [];
            const type = piece.toLowerCase();
            
            const addMove = (r, c) => {
                if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    const target = board[r][c];
                    if (!target || (isWhite && isBlackPiece(target)) || (!isWhite && isWhitePiece(target))) {
                        moves.push({row: r, col: c});
                        return !target;
                    }
                }
                return false;
            };
            
            if (type === 'p') {
                const dir = isWhite ? -1 : 1;
                if (!board[row + dir]?.[col]) moves.push({row: row + dir, col});
                [-1, 1].forEach(dc => {
                    if (board[row + dir]?.[col + dc]) moves.push({row: row + dir, col: col + dc});
                });
            } else if (type === 'n') {
                [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc]) => addMove(row + dr, col + dc));
            } else if (type === 'b' || type === 'q') {
                [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc]) => {
                    for (let i = 1; i < 8; i++) if (!addMove(row + i*dr, col + i*dc)) break;
                });
            }
            if (type === 'r' || type === 'q') {
                [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc]) => {
                    for (let i = 1; i < 8; i++) if (!addMove(row + i*dr, col + i*dc)) break;
                });
            } else if (type === 'k') {
                [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc]) => addMove(row + dr, col + dc));
            }
            return moves;
        }
        
        function getAllMoves(player) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && ((player === 'white' && isWhitePiece(piece)) || 
                                  (player === 'black' && isBlackPiece(piece)))) {
                        const pieceMoves = getValidMoves(r, c);
                        pieceMoves.forEach(m => moves.push({from: {r, c}, to: m}));
                    }
                }
            }
            return moves;
        }
        
        function saveState() {
            moveHistory.push({
                board: JSON.parse(JSON.stringify(board)),
                castling: {...castlingRights}
            });
        }
        
        function evaluateBoard() {
            let score = 0;
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (!piece) continue;
                    
                    const isWhite = isWhitePiece(piece);
                    const type = piece.toLowerCase();
                    const multiplier = isWhite ? -1 : 1;
                    
                    score += PIECE_VALUES[type] * multiplier;
                    
                    const tableRow = isWhite ? 7 - r : r;
                    const tableIdx = tableRow * 8 + c;
                    
                    if (type === 'p') score += PAWN_TABLE[tableIdx] * multiplier;
                    else if (type === 'n') score += KNIGHT_TABLE[tableIdx] * multiplier;
                    else if (type === 'b') score += BISHOP_TABLE[tableIdx] * multiplier;
                    else if (type === 'k') score += KING_TABLE[tableIdx] * multiplier;
                }
            }
            
            return score;
        }
        
        function minimax(depth, alpha, beta, maximizing) {
            if (depth === 0) {
                return evaluateBoard();
            }
            
            const player = maximizing ? 'black' : 'white';
            const moves = getAllMoves(player);
            
            if (moves.length === 0) {
                if (isInCheck(player)) return maximizing ? -999999 : 999999;
                return 0;
            }
            
            if (maximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    applyMove(move);
                    const evaluation = minimax(depth - 1, alpha, beta, false);
                    undoLastMove();
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    applyMove(move);
                    const evaluation = minimax(depth - 1, alpha, beta, true);
                    undoLastMove();
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }
        
        function applyMove(move) {
            saveState();
            const piece = board[move.from.r][move.from.c];
            
            if (move.to.castle) {
                if (move.to.castle === 'k') {
                    board[0][6] = 'k';
                    board[0][4] = null;
                    board[0][5] = 'r';
                    board[0][7] = null;
                } else if (move.to.castle === 'q') {
                    board[0][2] = 'k';
                    board[0][4] = null;
                    board[0][3] = 'r';
                    board[0][0] = null;
                }
            } else {
                // Handle en passant
                if (move.to.enPassant) {
                    board[move.from.r][move.to.col] = null;
                }
                let finalPiece = piece;
                if (piece && piece.toLowerCase() === 'p' && (move.to.row === 0 || move.to.row === 7)) {
                    finalPiece = piece === 'P' ? 'Q' : 'q';
                }
                board[move.to.row][move.to.col] = finalPiece;
                board[move.from.r][move.from.c] = null;
            }
            
            // Track last move
            lastMove = {from: {r: move.from.r, c: move.from.c}, to: {r: move.to.row, c: move.to.col}};
            
            if (piece === 'k') {
                castlingRights.blackKing = false;
                castlingRights.blackQueenside = false;
            } else if (piece === 'r') {
                if (move.from.r === 0 && move.from.c === 7) castlingRights.blackKing = false;
                if (move.from.r === 0 && move.from.c === 0) castlingRights.blackQueenside = false;
            }
        }
        
        function makeAIMove() {
            const randomMessage = AI_MESSAGES[Math.floor(Math.random() * AI_MESSAGES.length)];
            showAIMessage(randomMessage);
            
            const aiPlayer = playerColor === 'white' ? 'black' : 'white';
            const playerPlayer = playerColor;
            const moves = getAllMoves(aiPlayer);
            
            if (moves.length === 0) {
                if (isInCheck(aiPlayer)) {
                    setTimeout(() => {
                        document.getElementById('checkmateOverlay').style.display = 'flex';
                        document.getElementById('checkmateText').textContent = 'NEXUS wins!';
                    }, 500);
                } else {
                    setTimeout(() => {
                        document.getElementById('stalemateOverlay').style.display = 'flex';
                    }, 500);
                }
                return;
            }
            
            let bestMove = null;
            let bestValue = playerColor === 'white' ? -Infinity : Infinity;
            
            for (const move of moves) {
                applyMove(move);
                const value = minimax(searchDepth - 1, -Infinity, Infinity, playerColor === 'white');
                undoLastMove();
                
                if (playerColor === 'white') {
                    if (value > bestValue) {
                        bestValue = value;
                        bestMove = move;
                    }
                } else {
                    if (value < bestValue) {
                        bestValue = value;
                        bestMove = move;
                    }
                }
            }
            
            if (bestMove) {
                setTimeout(() => {
                    applyMove(bestMove);
                    currentPlayer = playerColor;
                    renderBoard();
                    
                    const checkMatePlayer = playerColor === 'white' ? 'black' : 'white';
                    const stalemateCheckPlayer = playerColor === 'white' ? 'black' : 'white';
                    
                    if (isCheckmate(playerColor)) {
                        document.getElementById('checkmateOverlay').style.display = 'flex';
                        document.getElementById('checkmateText').textContent = 'NEXUS wins!';
                    } else if (isStalemate(playerColor)) {
                        document.getElementById('stalemateOverlay').style.display = 'flex';
                    } else {
                        updateStatus();
                    }
                }, 1000);
            }
        }
        
        function showAIMessage(message) {
            const speechEl = document.getElementById('aiSpeech');
            speechEl.textContent = message;
            speechEl.style.display = 'block';
            setTimeout(() => {
                speechEl.style.display = 'none';
            }, 2000);
        }
        
        const MUSIC_LIBRARY = {
            epic: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3',
            classical: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3',
            ambient: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3',
            jazz: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3',
            electronic: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3'
        };
        
        function changeMusic() {
            const selector = document.getElementById('musicSelector');
            const selectedTrack = selector.value;
            const audio = document.getElementById('backgroundMusic');
            const source = document.getElementById('musicSource');
            
            source.src = MUSIC_LIBRARY[selectedTrack];
            audio.load();
            
            if (musicPlaying) {
                audio.play().catch(() => {
                    // Browser might block auto-play
                });
            }
        }
        
        function toggleMusic() {
            const audio = document.getElementById('backgroundMusic');
            const control = document.getElementById('musicControl');
            
            if (musicPlaying) {
                audio.pause();
                control.textContent = 'üîá';
                control.classList.add('muted');
            } else {
                audio.play().catch(() => {
                    // Browser might block auto-play
                });
                control.textContent = 'üîä';
                control.classList.remove('muted');
            }
            musicPlaying = !musicPlaying;
        }
        
        function isCheckmate(player) {
            return getAllMoves(player).length === 0 && isInCheck(player);
        }
        
        function isStalemate(player) {
            return getAllMoves(player).length === 0 && !isInCheck(player);
        }
        
        function updateStatus(msg) {
            const status = document.getElementById('status');
            if (msg) {
                status.textContent = msg;
                status.className = 'status thinking';
            } else {
                if (isCheckmate('white')) {
                    status.textContent = 'Checkmate! Black wins!';
                    status.className = 'status';
                } else if (isCheckmate('black')) {
                    status.textContent = 'Checkmate! White wins!';
                    status.className = 'status';
                } else if (isStalemate('white') || isStalemate('black')) {
                    status.textContent = 'Stalemate!';
                    status.className = 'status';
                } else if (isInCheck('white')) {
                    status.textContent = 'Check! Your turn (White)';
                    status.className = 'status';
                } else if (isInCheck('black')) {
                    status.textContent = 'Check! AI\'s turn (Black)';
                    status.className = 'status';
                } else {
                    status.textContent = currentPlayer === 'white' ? 'Your turn (White)' : 'AI\'s turn (Black)';
                    status.className = 'status';
                }
            }
        }
        
        function newGame() {
            document.getElementById('checkmateOverlay').style.display = 'none';
            document.getElementById('stalemateOverlay').style.display = 'none';
            initBoard();
        }
        
        function undoMove() {
            if (moveHistory.length >= 2) {
                undoLastMove();
                undoLastMove();
                currentPlayer = 'white';
                selectedSquare = null;
                renderBoard();
                updateStatus();
            }
        }
        
        function undoLastMove() {
            if (moveHistory.length > 0) {
                const state = moveHistory.pop();
                board = state.board;
                castlingRights = state.castling;
            }
        }
        
        function changeDifficulty() {
            searchDepth = parseInt(document.getElementById('difficulty').value);
        }
        
        // Auto-play background music on load
        window.addEventListener('load', () => {
            const audio = document.getElementById('backgroundMusic');
            audio.volume = 0.3;
            audio.play().catch(() => {
                // Browser might block auto-play, that's fine
            });
        });
        
        initBoard();
    </script>
</body>
</html>
